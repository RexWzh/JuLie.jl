<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>About · JuLie</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="JuLie logo"/></a><div class="docs-package-name"><span class="docs-autofit">JuLie</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>About</a><ul class="internal"><li><a class="tocitem" href="#Using"><span>Using</span></a></li><li><a class="tocitem" href="#Motivation"><span>Motivation</span></a></li><li><a class="tocitem" href="#New-to-Julia?"><span>New to Julia?</span></a></li><li><a class="tocitem" href="#Basic-algebraic-structures"><span>Basic algebraic structures</span></a></li><li><a class="tocitem" href="#Developing"><span>Developing</span></a></li><li><a class="tocitem" href="#Acknowledgments"><span>Acknowledgments</span></a></li><li><a class="tocitem" href="#Contributors"><span>Contributors</span></a></li></ul></li><li><a class="tocitem" href="combinatorics/">Combinatorics</a></li><li><a class="tocitem" href="lie-theory/">Lie theory</a></li><li><a class="tocitem" href="julie-index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>About</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>About</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ulthiel/JuLie.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="JuLie.jl"><a class="docs-heading-anchor" href="#JuLie.jl">JuLie.jl</a><a id="JuLie.jl-1"></a><a class="docs-heading-anchor-permalink" href="#JuLie.jl" title="Permalink"></a></h1><p>JuLie.jl is an early-stage <a href="https://julialang.org">Julia</a>/<a href="https://oscar.computeralgebra.de">OSCAR</a> package with the goal to provide structures and fast algorithms for things around <a href="https://en.wikipedia.org/wiki/Lie_theory">algebraic Lie theory</a>, <a href="https://en.wikipedia.org/wiki/Representation_theory">representation theory</a>, and relevant <a href="https://en.wikipedia.org/wiki/Combinatorics">combinatorics</a>. These fields are huge and this package is still small—I hope it will grow with time. Contributions are necessary and very much welcome!</p><p>By Ulrich Thiel (<a href="https://ulthiel.com/math">ulthiel.com/math</a>) and <a href="#Contributors">contributors</a>.</p><h2 id="Using"><a class="docs-heading-anchor" href="#Using">Using</a><a id="Using-1"></a><a class="docs-heading-anchor-permalink" href="#Using" title="Permalink"></a></h2><p>To install the package, you first need to install <a href="https://julialang.org">Julia</a>. Then after starting Julia, type the following:</p><pre><code class="language-julia-repl">julia&gt; using Pkg
julia&gt; Pkg.add(url=&quot;https://github.com/ulthiel/JuLie.jl&quot;)</code></pre><p>Now, you can start using the package as follows:</p><pre><code class="language-julia-repl">julia&gt; using JuLie
julia&gt; partitions(10)</code></pre><p>You can get help for a function by putting a question mark in front, e.g.</p><pre><code class="language-julia-repl">julia&gt; ?partitions</code></pre><h2 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h2><p>Especially for combinatorics there&#39;s a lot already in other computer algebra systems and this justifies the question: why another package? I will give 3 (interwoven) reasons:</p><ol><li><p>I want to create a package that covers the mathematics that I especially care about in a way that I think about it. One distant goal is to have all the material available from the book <a href="https://www.springer.com/gp/book/9783030488253">Introduction to Soergel bimodules</a> with Elias, Makisumi, and Williamson. It will take a lot of time and I don&#39;t know if I succeed but it&#39;s one motivation.</p></li><li><p>I hope this package will eventually form one pillar of the <a href="https://oscar.computeralgebra.de">OSCAR</a> project.</p></li><li><p>What really convinced me of Julia as programming language—and thus of the whole enterprise—is its straightforward high-level syntax (like Python) paired with incredible performance (unlike Python). Have a look at the following examples creating the list (not an iterator) of all <a href="https://en.wikipedia.org/wiki/Partition_(number_theory)">partitions</a> of the integer 90 (there are ~56.6 million) in different computer algebra systems.</p></li></ol><p>In <strong><a href="https://www.sagemath.org">Sage</a></strong> (v9.1):</p><pre><code class="language-none">sage: time X=Partitions(90).list()
Wall time: 3min 5s
#Uses 26.665GiB mem, quitting Sage takes quite a bit of time</code></pre><p>In <strong><a href="https://www.gap-system.org">GAP</a></strong> (v4.11.0):</p><pre><code class="language-none">gap&gt; L:=Partitions(90);; time/1000.0;
51.962
#Uses 11.8477 GiB mem, still works fine</code></pre><p>In <strong><a href="http://magma.maths.usyd.edu.au/magma/">Magma</a></strong> (v2.25-5):</p><pre><code class="language-none">&gt; time X:=Partitions(90);
Time: 32.990
//Uses 15.688 GiB mem, Magma unusable from now on</code></pre><p>And now, in <strong><a href="https://julialang.org">Julia</a></strong> (v1.5.2, my implementation):</p><pre><code class="language-none">julia&gt; @time partitions(Int8(90));
5.447290 seconds (56.63 M allocations: 6.239 GiB, 46.77% gc time)
#No problem afterwards</code></pre><p>I&#39;m cheating here a bit because I&#39;m using 8-bit integers (thus saving memory). But having the possibility to work with special integer types is very useful sometimes. Of course, you can do the same in C—but Julia is a high-level language with a similar simple syntax like Python, so why would anyone still go through such a pain?</p><h2 id="New-to-Julia?"><a class="docs-heading-anchor" href="#New-to-Julia?">New to Julia?</a><a id="New-to-Julia?-1"></a><a class="docs-heading-anchor-permalink" href="#New-to-Julia?" title="Permalink"></a></h2><p>You can learn all the basics of Julia from the <a href="https://docs.julialang.org/">Julia documentation</a> but as this is quite a lot to read, I&#39;ll mention a few key points.</p><p>First of all, you may have noticed that the first time you call a function like <code>partitions(10)</code> it takes a bit of time to get an answer—but the second time you call it (with any argument) the answer is immediate. This is because Julia uses <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">just-in-time (JIT) compilation</a>, which means it compiles code at run time just before it is actually needed. This is part of what makes Julia so fast—with the tradeoff that there will be a delay in the first call of a function.</p><p>Second, there are two—but likely more—caveats for algebraists in Julia: integers are by default 64-bit integers and division is floating point division:</p><pre><code class="language-julia-repl">julia&gt; 2^64
0
julia&gt; typeof(2)
Int64
julia&gt; 6/9
0.6666666666666666
julia&gt; typeof(6/9)
Float64</code></pre><p>This is of course not what we want. Before we fix this, notice from the example above that every object in Julia is of a certain <em>type</em>, e.g. <code>Int64</code> in case of the number 2. An object of a type called <code>MyType</code> can be created from input data required by this type by calling <code>MyType(...)</code>, where the dots represent the input data. For example, Julia provides the type <code>BigInt</code> for big integers (based on the <a href="https://gmplib.org">GMP</a> library) and we can create big integers as follows:</p><pre><code class="language-julia-repl">julia&gt; a = BigInt(2)
2
julia&gt; typeof(a)
BigInt
julia&gt; a^64
18446744073709551616</code></pre><p>Much better! Typically, names of types start with an uppercase letter while names of functions start with a lowercase letter. The operator for exact division in Julia is the double slash <code>//</code>:</p><pre><code class="language-julia-repl">julia&gt; x = 6//9
2//3
julia&gt; typeof(x)
Rational{Int64}</code></pre><p>You see that there is a type <code>Rational</code> for (exact) rational numbers in Julia. This type is actually a <em>parametric type</em> <code>Rational{T}</code> which means that it refers to rational numbers created from integers of type <code>T</code>—in this case 64-bit integers. I&#39;ll leave it to you to find out the type of a division of two big integers.</p><p>The advantage of types is that we can write functions with the same name but reacting differently depending on the input types, e.g. the operator <code>*</code> can be used to multiply integers, polynomials, group elements, etc.</p><h2 id="Basic-algebraic-structures"><a class="docs-heading-anchor" href="#Basic-algebraic-structures">Basic algebraic structures</a><a id="Basic-algebraic-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-algebraic-structures" title="Permalink"></a></h2><p>Basic algebraic structures are provided by the <a href="https://nemocas.github.io/AbstractAlgebra.jl/stable/">AbstractAlgebra</a> and <a href="https://nemocas.github.io/Nemo.jl/stable/">Nemo</a> packages (which are part of OSCAR). Whereas the former provides generic algebraic structures in pure Julia (like a general type of rings and of polynomial rings over a ring), the latter provides very fast arithmetic for special rings (like the integers and polynomial rings over the integers)—often based on the <a href="https://www.flintlib.org">FLINT</a> library. In JuLie we make use of these packages. Instead of importing the packages as a whole, we just import what we actually need to have maximal control (see the main file <code>src/JuLie.jl</code>). Some of the functions and structures are exported again so that they can be used directly from within JuLie without having to load the packages first, e.g.:</p><ul><li>Big <a href="https://nemocas.github.io/Nemo.jl/stable/integer/">integers</a> of type <code>fmpz</code> (with shortcut constructor <code>ZZ</code>) from Nemo. We prefer this to <code>BigInt</code> because it is what is used in Nemo and is faster.</li><li>Big exact <a href="https://nemocas.github.io/Nemo.jl/stable/rational/">rationals</a> of type <code>fmpq</code> (with shortcut <code>QQ</code>) from Nemo.</li><li><a href="https://nemocas.github.io/Nemo.jl/stable/finitefield/">Finite fields</a> from Nemo, e.g. <code>R, x = FiniteField(7, 3, &quot;x&quot;)</code> creates the field of characteristic 7 and of degree 3 over the prime field (i.e. having 7³=343 elements) and with primitive element <code>x</code>.</li><li><a href="https://nemocas.github.io/Nemo.jl/dev/polynomial/">Univariant polynomial rings</a>, e.g. <code>R, x = PolynomialRing(ZZ, &quot;x&quot;)</code> creates the  univariate polynomial ring over the integers with indeterminate <code>x</code>. This is implemented generically in AbstractAlgebra but there are special types for rings optimized in Nemo.</li><li><a href="https://nemocas.github.io/Nemo.jl/dev/mpolynomial/">Multivariate polynomial rings</a>, e.g. <code>R, (x, y) = PolynomialRing(ZZ, [&quot;x&quot;, &quot;y&quot;])</code> creates the multivariate polynomial ring over the integers with indeterminates <code>x</code> and <code>y</code>. Again, there are special types for rings optimized in Nemo.</li><li><a href="https://nemocas.github.io/AbstractAlgebra.jl/stable/laurent_polynomial/">Univariate Laurent polynomial rings</a>, e.g. <code>R, x = LaurentPolynomialRing(ZZ, &quot;x&quot;)</code>.</li><li><a href="https://nemocas.github.io/Nemo.jl/stable/matrix/">Matrices</a>, e.g. <code>M = matrix(ZZ, [3 1 2; 2 0 1])</code>. Again, there are special types for rings optimized in Nemo.</li><li><a href="https://nemocas.github.io/AbstractAlgebra.jl/stable/free_module/">Vector spaces</a>, e.g. <code>VectorSpace(QQ, 2)</code>, and <a href="https://nemocas.github.io/AbstractAlgebra.jl/stable/free_module/">free modules</a>, e.g. <code>FreeModule(ZZ, 3)</code>.</li><li><a href="https://nemocas.github.io/AbstractAlgebra.jl/stable/perm/">Symmetric groups</a>, e.g. <code>SymmetricGroup(6)</code>.</li></ul><p>Of course, anything from any package can be used as well after loading it in Julia.</p><h2 id="Developing"><a class="docs-heading-anchor" href="#Developing">Developing</a><a id="Developing-1"></a><a class="docs-heading-anchor-permalink" href="#Developing" title="Permalink"></a></h2><p>Contributions are necessary and very much welcome. Here are some guidelines.</p><h3 id="Setting-up-the-repository"><a class="docs-heading-anchor" href="#Setting-up-the-repository">Setting up the repository</a><a id="Setting-up-the-repository-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-repository" title="Permalink"></a></h3><p>Clone this repository to somewhere on your computer:</p><pre><code class="language-none">git clone https://github.com/ulthiel/JuLie.jl</code></pre><p>Enter the directory &quot;JuLie.jl&quot;, start Julia, hit the &quot;]&quot; key to enter REPL mode, and then add the package to the registry:</p><pre><code class="language-none">dev .</code></pre><p>Exit the REPL mode by hitting the backspace key. Then you can start using the package as usual with</p><pre><code class="language-none">using JuLie</code></pre><p>Any changes you make to the code now will not be available in the current Julia session—you have to restart it. This is simply the way Julia works but this is annoying when developing. A solution is to load the <a href="https://timholy.github.io/Revise.jl/v0.6/">Revise</a> package before loading the package.</p><pre><code class="language-none">using Pkg
Pkg.add(&quot;Revise&quot;)
using Revise
using JuLie</code></pre><p>Now, changes you make in the code are immediately available in the Julia session (except for changes to structures, here you need to restart).</p><h3 id="Programming-guidelines"><a class="docs-heading-anchor" href="#Programming-guidelines">Programming guidelines</a><a id="Programming-guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Programming-guidelines" title="Permalink"></a></h3><ol><li>Check out the <a href="https://docs.julialang.org/en/v1/">Julia Documentation</a>, especially the <a href="https://docs.julialang.org/en/v1/manual/style-guide/">Style Guide</a> and the <a href="https://docs.julialang.org/en/v1/manual/performance-tips/">Performance Guide</a>.</li><li>Check out the section on basic algebraic structures above. In particular, we use <code>fmpz</code> for big integers and whatever we can use from AbstractAlgebra and Nemo.</li><li>I am collecting all the global imports from other packages in the main file <code>JuLie.jl</code>. If you need more imports, then first put them <em>not</em> here but in the file you are working on. When you&#39;re finished we can move the imports you need to the main file.</li><li>Have a look at the file <code>src/partitions.jl</code> to see how the stuff works and how I want code to look like.</li><li>You can use unicode characters in the code—I find it cleaner to write λ instead of &quot;lambda&quot;. The <a href="https://docs.julialang.org/en/v1/manual/unicode-input/">LaTex-like abbreviations</a> can be used in, e.g., the <a href="https://atom.io">Atom</a> editor.</li><li>We use <em>one hard</em> Tab for indentation.</li><li>Everything has to be well-documented, algorithms and papers have to be properly referenced. You can build the documentation locally with <code>julia make.jl local</code> in the directory <code>docs</code>.</li><li>If your implementation is not more efficient than those in other computer algebra systems then it&#39;s not good enough. (Don&#39;t take this too seriously, but at least try. I prefer to have a not incredibly fast algorithm than no algorithm at all.)</li><li>For every function you implement, there has to be a reasonable test in <code>test/runtests.jl</code>. Try to find computed examples in publications or which follow from general theory etc. You can run the complete unit test with <code>Pkg.test(&quot;JuLie&quot;)</code>.</li></ol><h2 id="Acknowledgments"><a class="docs-heading-anchor" href="#Acknowledgments">Acknowledgments</a><a id="Acknowledgments-1"></a><a class="docs-heading-anchor-permalink" href="#Acknowledgments" title="Permalink"></a></h2><p>This is a contribution to Project-ID 286237555 – TRR 195 – by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation). I also thank my contributors, see below.</p><h2 id="Contributors"><a class="docs-heading-anchor" href="#Contributors">Contributors</a><a id="Contributors-1"></a><a class="docs-heading-anchor-permalink" href="#Contributors" title="Permalink"></a></h2><ul><li><a href="https://www.quendi.de/en/math">Max Horn</a> (TU Kaiserslautern, 2020–)</li><li>Tom Schmit (TU Kaiserslautern, 2020–2021)</li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="combinatorics/">Combinatorics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 3 August 2021 18:17">Tuesday 3 August 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
