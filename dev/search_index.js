var documenterSearchIndex = {"docs":
[{"location":"partitions/#Partitions-and-the-like","page":"Partitions and the like","title":"Partitions and the like","text":"","category":"section"},{"location":"partitions/#Compositions","page":"Partitions and the like","title":"Compositions","text":"","category":"section"},{"location":"partitions/","page":"Partitions and the like","title":"Partitions and the like","text":"Composition\ncompositions\nnum_compositions","category":"page"},{"location":"partitions/#JuLie.Composition","page":"Partitions and the like","title":"JuLie.Composition","text":"Composition{T} <: AbstractArray{T,1}\n\nA composition of an integer n ≥ 0 is a sequence (λ₁,…,λᵣ) of positive integers whose sum is equal to n. We have implemented an own type Composition as subtype of AbstractArray{T,1}.\n\nExample\n\njulia> c=Composition([2,1])\njulia> sum(c)\n3\n\n\n\n\n\n","category":"type"},{"location":"partitions/#JuLie.compositions","page":"Partitions and the like","title":"JuLie.compositions","text":"compositions(n::Integer, k::Integer)\n\nReturns an array of all compositions of n into k parts. The algorithm used is Algorithm 72 \"Composition Generator\" by L. Hellerman and S. Ogden, Communications of the ACM, 1961 (which refers to John Riordan, An Introduction to Combinatorial Analysis, 1958, Chapter 6). There may be faster algorithms—I don't know—but we're at least way faster than Sage (and also GAP4). De-gotoed by Elisa (as usual).\n\njulia> @time X=compositions(26);\n  5.189374 seconds (33.56 M allocations: 6.863 GiB, 20.09% gc time)\n\n\n\n\n\ncompositions(n::Integer)\n\nReturns an array of all compositions of an integer n. This iterates over compositions of n into k parts for 1 ≤ k ≤ n.\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.num_compositions","page":"Partitions and the like","title":"JuLie.num_compositions","text":"num_compositions(n::Integer)\n\nThe number of compositons of an integer n>0 is equal to 2^n-1. For n=0 there is 1 composition (the empty one) by convention. See OEIS for more information.\n\n\n\n\n\n","category":"function"},{"location":"partitions/#Partitions","page":"Partitions and the like","title":"Partitions","text":"","category":"section"},{"location":"partitions/","page":"Partitions and the like","title":"Partitions and the like","text":"Partition\npartitions\nnum_partitions\ndominates\nconjugate\ngetelement\nascending_partitions","category":"page"},{"location":"partitions/#JuLie.Partition","page":"Partitions and the like","title":"JuLie.Partition","text":"Partition{T} <: AbstractArray{T,1}\n\nA partition of an integer n ≥ 0 is a decreasing sequence λ=(λ₁,…,λᵣ) of positive integers λᵢ whose sum is equal to n. The λᵢ are called the parts of the partition. We encode a partition as an array with elements λᵢ. To be able to conceptually work with partitions we have implemented an own type Partition{T} as subtype of AbstractArray{T,1}. All functions for arrays then also work for partitions. You may increase performance by using smaller integer types, see the example below. For efficiency, the Partition constructor does not check whether the given array is in fact a partition, i.e. a decreasing sequence.\n\nFor more general information on partitions, check out Wikipedia.\n\nExample\n\njulia> P=Partition([3,2,1]) #The partition 3+2+1 of 6\njulia> sum(P) #The sum of the parts.\n6\njulia> P[1] #First component\n3\njulia> P=Partition(Int8[3,2,1]) #Same partition but using 8 bit integers\n\nRemarks\n\nUsually, |λ| ≔ n is called the size of λ. In Julia, the function size for arrays already exists and returns the dimension of an array. Instead, you can use sum to get the sum of the parts.\nThere is no performance impact by using an own type for partitions rather than simply using arrays—I've tested this. Julia is great. The implementation of a subtype of AbstractArray is explained in the Julia documentation.\n\n\n\n\n\n","category":"type"},{"location":"partitions/#JuLie.partitions","page":"Partitions and the like","title":"JuLie.partitions","text":"partitions(n::Integer)\n\nA list of all partitions of an integer n ≥ 0, produced in lexicographically descending order. This ordering is like in SAGE, but opposite to GAP. You can apply reverse() to reverse the order. As usual, you may increase performance by using smaller integer types. The algorithm used is [1, Algorithm ZS1].\n\nExample\n\njulia> partitions(Int8(90)) #Using 8-bit integers\n\nReferences\n\nA. Zoghbi and I. Stojmenovic, \"Fast algorithms for generating integer partitions\", Int. J. Comput. Math. 70 (1998), no. 2, 319–332.\n\n\n\n\n\npartitions(m::Integer, n::Integer, l1::Integer, l2::Integer; z=0)\n\nA list of all partitions of an integer m ≥ 0 into n ≥ 0 parts with lower bound l1 ≥ 0 and upper bound l2 ≥ l1 for the parts. There are two choices for the parameter z:\n\nz=0: no further restriction (default);\nz=1: only distinct parts.\n\nThe partitions are produced in decreasing order.\n\nThe algorithm used is \"parta\" in 1.\n\nRefereces\n\nW. Riha and K. R. James, \"Algorithm 29. Efficient Algorithms for Doubly and Multiply Restricted Partitions\" (1976).\n\n\n\n\n\npartitions(m::Integer, n::Integer)\n\nAll partitions of an integer m ≥ 0 into n ≥ 1 parts (no further restrictions). This simply calls partitions(m,n,1,m,z=0).\n\n\n\n\n\npartitions(mu::Array{Integer,1}, m::Integer, v::Array{Integer,1}, n::Integer)\n\nAll partitions of an integer m >= 0 into n >= 1 parts, where each part is an element in v and each v[i] occurs a maximum of mu[i] times. The partitions are produced in\tdecreasing order. The algorithm used is a de-gotoed version of \"partb\" in [1].\n\nRemark\n\nThe original algorithm lead to BoundsErrors, since r could get smaller than 1. Furthermore x and y are handled as Arrays with an infinite length. After finding all valid partitions, the algorithm will continue searching for partitions of length n+1. We thus had to add a few additional checks and interruptions.\n\nReferences\n\nW. Riha and K. R. James, \"Algorithm 29. Efficient Algorithms for Doubly and Multiply Restricted Partitions\" (1976).\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.num_partitions","page":"Partitions and the like","title":"JuLie.num_partitions","text":"num_partitions(n::fmpz)\nnum_partitions(n::Integer)\n\nThe number of integer partitions of the integer n ≥ 0. Uses the function from FLINT, which is really fast.\n\nReferences\n\nOEIS\n\n\n\n\n\nnum_partitions(n::fmpz, k::fmpz)\nnum_partitions(n::Integer, k::Integer)\n\nThe number of integer partitions of the integer n ≥ 0 into k ≥ 0 parts. The implementation uses a recurrence relation.\n\nReferences\n\nOEIS\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.dominates","page":"Partitions and the like","title":"JuLie.dominates","text":"dominates(λ::Partition, μ::Partition)\n\nThe dominance order on partitions is the partial order ⊵ defined by λ ⊵ μ if and only if λ₁ + … + λᵢ ≥ μ₁ + … + μᵢ for all i. This function returns true if λ ⊵ μ.\n\nReferences\n\nWikipedia.\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.conjugate","page":"Partitions and the like","title":"JuLie.conjugate","text":"conjugate(λ::Partition{T}) where T<:Integer\n\nThe conjugate of a partition is obtained by considering its Young diagram (see Tableau) and then flipping it along its main diagonal.\n\nReferences\n\nWikipedia.\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.getelement","page":"Partitions and the like","title":"JuLie.getelement","text":"getelement(P::Partition, i::Int)\n\nSometimes in algorithms for partitions it is convenient to be able to access parts beyond the length of the partition, and then you want to get zero instead of an error. This function is a shortcut for\n\nreturn (i>length(P.p) ? 0 : getindex(P.p,i))\n\nIf you are sure that P[i] exists, use getindex because this will be faster.\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.ascending_partitions","page":"Partitions and the like","title":"JuLie.ascending_partitions","text":"ascending_partitions(n::Integer;alg=\"ks\")\n\nInstead of encoding a partition of an integer n ≥ 0 as a descending sequence (which is our convention), one can also encode it as an ascending sequence. In the papers [1,2] it is said that generating the list of all ascending partitions is more efficient than generating descending ones. To test this, I have implemented the algorithms:\n\n\"ks\" (default) is the algorithm AccelAsc (Algorithm 4.1) in [1].\n\"m\" is Algorithm 6 in [2]. This is similar to \"ks\".\n\nThe ascending partitions are given here as arrays, not of type Partition since these are descending by our convention. I am using \"ks\" as default since it looks slicker and I believe there is a tiny mistake in the publication of \"m\" (which I fixed).\n\nComparison\n\nI don't see a significant speed difference to the descending encoding:\n\njulia> @btime partitions(Int8(90));\n\t3.376 s (56634200 allocations: 6.24 GiB)\n\njulia> @btime ascending_partitions(Int8(90),alg=\"ks\");\n\t3.395 s (56634200 allocations: 6.24 GiB)\n\njulia> @btime ascending_partitions(Int8(90),alg=\"m\");\n\t3.451 s (56634200 allocations: 6.24 GiB)\n\nReferences\n\nJ. Kelleher and B. O'Sullivan, \"Generating All Partitions: A Comparison Of Two Encodings\", https://arxiv.org/pdf/0909.2331.pdf, May 2014.\nMerca, \"Fast Algorithm for Generating Ascending Compositions\", J. Math Model. Algor. (2012) 11:89–104.\n\n\n\n\n\n","category":"function"},{"location":"partitions/#Multipartitions","page":"Partitions and the like","title":"Multipartitions","text":"","category":"section"},{"location":"partitions/","page":"Partitions and the like","title":"Partitions and the like","text":"Multipartition\nmultipartitions\nnum_multipartitions\nsum(P::Multipartition{T}) where T<:Integer","category":"page"},{"location":"partitions/#JuLie.Multipartition","page":"Partitions and the like","title":"JuLie.Multipartition","text":"Multipartition{T} <: AbstractArray{Partition{T},1}\n\nMultipartitions are generalizations of partitions. An r-component multipartition of an integer n is an r-tuple of partitions λ¹, λ², …, λʳ where each λⁱ is a partition of some integer nᵢ ≥ 0 and the nᵢ sum to n. As for partitions, we have implemented an own type Multipartition{T} which is a subtype of AbstractArray{Partition{T},1}. As with partitions, you can can use smaller integer types to increase performance.\n\nExample\n\njulia> P=Multipartition( [[2,1], [], [3,2,1]] )\njulia> sum(P)\n9\njulia> P[2]\nInt64[]\njulia> Multipartition( Array{Int8,1}[[2,1], [], [3,2,1]] ) #Using 8-bit integers\n\n\n\n\n\n","category":"type"},{"location":"partitions/#JuLie.multipartitions","page":"Partitions and the like","title":"JuLie.multipartitions","text":"multipartitions(n::T, r::Integer) where T<:Integer\n\nA list of all r-component multipartitions of n.\n\nExample\n\njulia> multipartitions(Int8(3),2) #Using 8-bit integers\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.num_multipartitions","page":"Partitions and the like","title":"JuLie.num_multipartitions","text":"num_multipartitions(n::Int, k::Int)\n\nThe number of multipartitions of n into k parts. There's a straightforward way to count them, see [1, Proof of Lemma 2.4].\n\nReferences\n\nD. Craven, The Number of t-Cores of Size n (2006).\n\n\n\n\n\n","category":"function"},{"location":"partitions/#Base.sum-Union{Tuple{Multipartition{T}}, Tuple{T}} where T<:Integer","page":"Partitions and the like","title":"Base.sum","text":"sum(P::Multipartition{T}) where T<:Integer\n\nIf P is a multipartition of the integer n, this function returns n.\n\n\n\n\n\n","category":"method"},{"location":"partitions/#Multiset-partitions","page":"Partitions and the like","title":"Multiset partitions","text":"","category":"section"},{"location":"partitions/","page":"Partitions and the like","title":"Partitions and the like","text":"Multiset_partition\nmultiset_partitions","category":"page"},{"location":"partitions/#JuLie.Multiset_partition","page":"Partitions and the like","title":"JuLie.Multiset_partition","text":"Multiset_partition{T}\n\nMultiset-partitions are generalizations of partitions. An r-component multiset-partition of an integer n is a multiset(a set where each element can be contained multiple times) of partitions λ¹ λ²  λʳ where each λⁱ is a partition of some integer nᵢ  1 and the nᵢ sum to n. As for partitions, we have implemented an own type Multiset_partition{T}. As with partitions, you can can use smaller integer types to increase performance.\n\nExample\n\njulia> P = Multiset_partition( [2,1], [4], [3,2,1] )\n{[2, 1], [4], [3, 2, 1]}\njulia> sum(P)\n13\njulia> Multiset_partition( Array{Int8,1}[[2,1], [4], [3,2,1]] ) #Using 8-bit integers\n{Int8[2, 1], Int8[4], Int8[3, 2, 1]}\n\nSince Multiset-partitions are unordered sets, you can't call an explicit element, however, you can iterate over a Multiset_partition.\n\nExample\n\njulia> MSP = Multiset_partition( [2,1], [4], [3,2,1] )\n{[2, 1], [4], [3, 2, 1]}\njulia> for p in MSP println(p) end\n[2, 1]\n[4]\n[3, 2, 1]\n\n\n\n\n\n","category":"type"},{"location":"partitions/#JuLie.multiset_partitions","page":"Partitions and the like","title":"JuLie.multiset_partitions","text":"multiset_partitions(n::T) where T<:Integer\n\nA list of all multiset_partitions of an integer n  0.\n\nThe performance will suffer by casting n into a smaller integer type, e.g.\n\nmultiset_partitions(Int8(20))\n\n\n\n\n\nmultiset_partitions(p::Partition{T})\twhere T<:Integer\n\nA list of all possible multiset_partitions of a Partition, by regrouping its parts into Partitions.\n\nThe algorithm used is the algorithm M by , \"The Art of Computer Programming - Volume 4A, Combinatorial Algorithms, Part 1\" by Donald E. Knuth(2011), 429–430. De-gotoed, index-shifted and generalized.\n\n\n\n\n\nmultiset_partitions(n::T, r::Integer) where T<:Integer\n\nA list of all multiset_partitions of an integer n  0 into r  1 parts.\n\n\n\n\n\nmultiset_partitions(p::Partition{T}, r::Integer) where T<:Integer\n\nA list of all possible r-restricted multiset_partitions of a Partition, by regrouping its parts into Partitions.\n\nThe algorithm used is a version of the algorithm M by , \"The Art of Computer Programming - Volume 4A, Combinatorial Algorithms, Part 1\" by Donald E. Knuth, 429–430 http://www.cs.utsa.edu/~wagner/knuth/fasc3b.pdf. De-gotoed, index-shifted and generalized.\n\n\n\n\n\n","category":"function"},{"location":"partitions/#Tableaux","page":"Partitions and the like","title":"Tableaux","text":"","category":"section"},{"location":"partitions/","page":"Partitions and the like","title":"Partitions and the like","text":"Tableau\nshape\nweight\nreading_word\nis_semistandard\nsemistandard_tableaux\nis_standard\nstandard_tableaux\nhook_length\nhook_lengths\nnum_standard_tableaux\nschensted\nbump!","category":"page"},{"location":"partitions/#JuLie.Tableau","page":"Partitions and the like","title":"JuLie.Tableau","text":"Tableau{T} <: AbstractArray{AbstractArray{T,1},1}\n\nA Young diagram is a diagram of finitely many empty \"boxes\" arranged in left-justified rows, with the row lengths in non-increasing order. The box in row i and and column j has the coordinates (i,j). Listing the number of boxes in each row gives a partition λ of a non-negative integer n (the total number of boxes of the diagram). The diagram is then said to be of shape λ. Conversely, one can associate to any partition λ a Young diagram in the obvious way, so Young diagrams are just another way to look at partitions.\n\nA Young tableau of shape λ is a filling of the boxes of the Young diagram of λ with elements from some set. After relabeling we can (and will) assume that we fill from a set of integers from 1 up to some number, which in applications is often equal to n. We encode a tableau as an array of arrays and we have implemented an own type Tableau{T}\tas subtype of AbstractArray{AbstractArray{T,1},1} to work with tableaux. As for partitions, you may increase performance by casting into smaller integer types, e.g.\n\nFor efficiency, we do not check whether the given array is really a tableau, i.e. whether the structure of the array defines a partition.\n\nFor more information see Wikipedia.\n\nExample\n\nTab=Tableau([[1,2,3],[4,5],[6]])\nTab=Tableau(Array{Int8,1}[[2,1], [], [3,2,1]]) #Using 8 bit integers\n\n\n\n\n\n","category":"type"},{"location":"partitions/#JuLie.shape","page":"Partitions and the like","title":"JuLie.shape","text":"shape(Tab::Tableau{T})\n\nReturns the shape of a tableau.\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.weight","page":"Partitions and the like","title":"JuLie.weight","text":"weight(Tab::Tableau)\n\nThe weight of a tableau is the number of times each number appears in the tableau. The return value is an array whose i-th element gives the number of times the integer i appears in the tableau.\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.reading_word","page":"Partitions and the like","title":"JuLie.reading_word","text":"reading_word(Tab::Tableau)\n\nThe reading word of a tableau is the word obtained by concatenating the fillings of the rows, starting from the bottom row. The word is here returned as an array.\n\nExample\n\njulia> reading_word(Tableau([ [1,2,3] , [4,5] , [6] ]))\n6-element Array{Int64,1}:\n 6\n 4\n 5\n 1\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.is_semistandard","page":"Partitions and the like","title":"JuLie.is_semistandard","text":"is_semistandard(Tab::Tableau)\n\nA tableau is called semistandard if the entries weakly increase along each row and strictly increase down each column.\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.semistandard_tableaux","page":"Partitions and the like","title":"JuLie.semistandard_tableaux","text":"semistandard_tableaux(shape::Partition{T}, max_val=sum(shape)::Integer) where T<:Integer\n\nReturns a list of all semistandard tableaux of given shape and filling elements bounded by max_val. By default, max_val is equal to the sum of the shape partition (the number of boxes in the Young diagram). The list of tableaux is in lexicographic order from left to right and top to bottom.\n\n\n\n\n\nsemistandard_tableaux(shape::Partition{T}, max_val=sum(shape)::Integer) where T<:Integer\n\nShortcut for semistandard_tableaux(Partition(shape),max_val).\n\n\n\n\n\nsemistandard_tableaux(box_num::T, max_val=box_num::T) where T<:Integer\n\nReturns a list of all semistandard tableaux consisting of box_num boxes and filling elements bounded by max_val.\n\n\n\n\n\nsemistandard_tableaux(s::Array{T,1}, weight::Array{T,1}) where T<:Integer\n\nReturns a list of all semistandard tableaux with shape s and given weight. This requires that sum(s) = sum(weight).\n\n\n\n\n\nsemistandard_tableaux(s::Partition{T}, weight::Partition{T}) where T<:Integer\n\nSame as for semistandard_tableaux(s::Array{T,1}, weight::Array{T,1}) where T<:Integer.\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.is_standard","page":"Partitions and the like","title":"JuLie.is_standard","text":"is_standard(Tab::Tableau)\n\nA tableau is called standard if it is semistandard and the entries are in bijection with 1,…n, where n is the number of boxes.\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.standard_tableaux","page":"Partitions and the like","title":"JuLie.standard_tableaux","text":"standard_tableaux(s::Partition)\n\nReturns a list of all standard tableaux of a given shape.\n\n\n\n\n\nstandard_tableaux(s::Array{Integer,1})\n\nShortcut for standard_tableaux(Partition(s)).\n\n\n\n\n\nstandard_tableaux(n::Integer)\n\nReturns a list of all standard tableaux with n boxes.\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.hook_length","page":"Partitions and the like","title":"JuLie.hook_length","text":"hook_length(lambda::Partition, i::Integer, j::Integer)\n\nConsider the Young diagram of a partition λ. The hook length of a box, is the number of boxes to the right in the same row + the number of boxes below in the same column + 1. The function returns the hook length of the box with coordinates (i,j). The functions assumes that the box exists.\n\n\n\n\n\nhook_length(Tab::Tableau, i::Integer, j::Integer)\n\nShortcut for hook_length(shape(Tab),i,j).\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.hook_lengths","page":"Partitions and the like","title":"JuLie.hook_lengths","text":"hook_lengths(lambda::Partition)\n\nReturns the tableau of shape λ in which the entry at position (i,j) is equal to the hook length of the corresponding box.\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.num_standard_tableaux","page":"Partitions and the like","title":"JuLie.num_standard_tableaux","text":"num_standard_tableaux(lambda::Partition)\n\nReturns the number f^lambda of standard tableaux of shape λ using the hook length formula\n\nf^lambda = fracnprod_ij h_lambda(ij) \n\nwhere the product is taken over all boxes in the Young diagram of lambda and h_lambda denotes the hook length of the box (i,j).\n\nFor my information, see Wikipedia.\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.schensted","page":"Partitions and the like","title":"JuLie.schensted","text":"schensted(sigma::Array{Integer,1})\n\nThe Robinson–Schensted correspondence is a bijection between permutations and pairs of standard Young tableaux of the same shape. For a permutation sigma (given as an array), this function performs the Schnested algorithm and returns the corresponding pair of standard tableaux (the insertion and recording tableaux).\n\nFor more information, see Wikipedia.\n\nExample\n\njulia> schensted([3,1,6,2,5,4])\n(AbstractArray{Int64,1}[[1, 2, 4], [3, 5], [6]], AbstractArray{Int64,1}[[1, 3, 5], [2, 4], [6]])\n\n\n\n\n\n","category":"function"},{"location":"partitions/#JuLie.bump!","page":"Partitions and the like","title":"JuLie.bump!","text":"bump!(Tab::Tableau, x::Int)\n\nInserts the integer x into the tableau Tab according to the bumping algorithm by applying the Schensted insertion.\n\n\n\n\n\nbump!(Tab::Tableau, x::Integer, Q::Tableau, y::Integer)\n\nInserts x into Tab according to the bumping algorithm by applying the Schensted insertion. Traces the change with Q by inserting y at the same Position in Q as x in Tab.\n\n\n\n\n\n","category":"function"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"This is a logbook to keep track of the performance of JuLie compared to other computer algebra systems. It's not meant to belittle anyone—but as one of the goals of JuLie is to be fast, we need to verify that we're on the right track. In each section there's a description of a test (including a collapsible \"Code\" section containing the code used for the test) and a list of timings (on the same machine). If you find a mistake, please message me.","category":"page"},{"location":"benchmarks/#Partitions","page":"Benchmarks","title":"Partitions","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"We create the full list (not an iterator) of the partitions of the integer 90 (there are about 56.6 million). It's a good test for \"combinatorial speed\" and memory efficiency. We cheat a little because we use 8-bit integers in Julia which saves memory—but since this is a feature of Julia, why not use it?","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"JuLie Sage GAP Magma\n5.45 185 52.0 33.0","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"<details><summary>Code</summary>\n<pre>\nJuLie:\njulia> @time L=partitions(Int8(90));\n\nSage:\nsage: time L=Partitions(90).list()\n\nGAP:\ngap> L:=Partitions(90);; time/1000.0;\n\nMagma:\n> time L:=Partitions(90);\n</pre>\n</details>","category":"page"},{"location":"benchmarks/#Compositions","page":"Benchmarks","title":"Compositions","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Function JuLie Sage GAP Magma\ncatalan(2^20) 0.02[1] 22.1[2] — 1.72[3]\ncompositions(26) 4.98[4] 154[5] 49.7[6] —\npartitions(90) 5.45[7] 185[8] 52.0[9] 33.0[10]\nsemistandard_tableaux([5,3,2]) 0.88[11] 30.8[12] — —","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[1]: @time catalan(2^20)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[2]: time X=catalan_number(2^20)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[3]: time X:=Catalan(2^20);","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[4]: @time compositions(Int8(26));","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[5]: time X=Compositions(26).list()","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[6]: L:=OrderedPartitions(26);; time/1000.0;","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[7]: @time partitions(Int8(90));","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[8]: time X=Partitions(90).list()","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[9]: L:=Partitions(90);; time/1000.0;","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[10]: time X:=Partitions(90);","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[11]: @time semistandard_tableaux([5,3,2]);","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[12]: time X=SemistandardTableaux([5,3,2]).list()","category":"page"},{"location":"basic-alg-struct/#basic-alg-struct","page":"Basic algebraic structures","title":"Basic algebraic structures","text":"","category":"section"},{"location":"basic-alg-struct/","page":"Basic algebraic structures","title":"Basic algebraic structures","text":"The goal of the OSCAR project (which is short for Open Source Computer Algebra Research) is to develop a modern, high-performance, mathematically sound computer algebra system based on Julia and integrating existing computer algebra systems. Part of the OSCAR ecosystem are the following Julia packages:","category":"page"},{"location":"basic-alg-struct/","page":"Basic algebraic structures","title":"Basic algebraic structures","text":"AbstractAlgebra.jl: generic algebraic structures in pure Julia (like a general type of rings and of polynomial rings over a ring).\nNemo.jl: very fast arithmetic for special rings (like the integers and polynomial rings over the integers)—often based on the FLINT library.\nHecke.jl: algebraic number theory.\nGAP.jl: GAP integration.\nSingular.jl: Singular integration.\nOscar.jl: high-level package combining and extending the above.","category":"page"},{"location":"basic-alg-struct/","page":"Basic algebraic structures","title":"Basic algebraic structures","text":"JuLie may be considered as a further contribution to the OSCAR project and in particular integrates with and builds upon this ecosystem. Here is an overview of basic algebraic structures that are used in JuLie (see here for the full list of imports):","category":"page"},{"location":"basic-alg-struct/","page":"Basic algebraic structures","title":"Basic algebraic structures","text":"Big integers of type fmpz (with shortcut ZZ) from Nemo, e.g. ZZ(5). We prefer this to BigInt because it is what is used in Nemo and is faster.\nBig exact rationals of type fmpq (with shortcut QQ) from Nemo, e.g. QQ(5//3) or ZZ(5)//ZZ(3).\nFinite fields from Nemo, e.g. R, x = FiniteField(7, 3, \"x\") creates the field of characteristic 7 and of degree 3 over the prime field (i.e. having 7³=343 elements) and with primitive element x.\nCyclotomic fields from Nemo, e.g. K,z = CyclotomicField(3, \"z\").\nUnivariant polynomial rings, e.g. R, x = PolynomialRing(ZZ, \"x\") creates the  univariate polynomial ring over the integers with indeterminate x. This is implemented generically in AbstractAlgebra but there are special types for rings optimized in Nemo.\nMultivariate polynomial rings, e.g. R, (x, y) = PolynomialRing(ZZ, [\"x\", \"y\"]) creates the multivariate polynomial ring over the integers with indeterminates x and y. Again, there are special types for rings optimized in Nemo.\nUnivariate Laurent polynomial rings, e.g. R, x = LaurentPolynomialRing(ZZ, \"x\").\nMatrices, e.g. M = matrix(ZZ, [3 1 2; 2 0 1]). Again, there are special types for rings optimized in Nemo.\nVector spaces, e.g. VectorSpace(QQ, 2), and free modules, e.g. FreeModule(ZZ, 3).\nSymmetric groups, e.g. SymmetricGroup(6).","category":"page"},{"location":"combinatorics/#Combinatorics","page":"Combinatorics","title":"Combinatorics","text":"","category":"section"},{"location":"combinatorics/#Enumerative-functions","page":"Combinatorics","title":"Enumerative functions","text":"","category":"section"},{"location":"combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"bell(x::Int)\ncatalan\nlucas\nstirling1\nstirling2","category":"page"},{"location":"combinatorics/#Nemo.bell-Tuple{Int64}","page":"Combinatorics","title":"Nemo.bell","text":"bell(x::Int)\n\nReturn the Bell number B_x.\n\n\n\n","category":"method"},{"location":"combinatorics/#JuLie.catalan","page":"Combinatorics","title":"JuLie.catalan","text":"catalan(n::fmpz)\ncatalan(n::Integer)\n\nThe n-th Catalan number C_n. The computation simply uses the formula\n\nC_n = frac1n+1 2n choose n \n\nRefences\n\nWikipedia, Catalan number\nThe On-Line Encyclopedia of Integer Sequences, A000108\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/#JuLie.lucas","page":"Combinatorics","title":"JuLie.lucas","text":"lucas(n::fmpz)\nlucas(n::Integer)\n\nThe n-th Lucas number. The implementation is a wrapper to the function in GMP.\n\nReferences\n\nOEIS\nWikipedia\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/#JuLie.stirling1","page":"Combinatorics","title":"JuLie.stirling1","text":"stirling1(n::fmpz, k::fmpz)\nstirling1(n::Integer, k::Integer)\n\nThe Stirling number S₁(n,k) of the first kind. The absolute value of S₁(n,k) counts the number of permutations of n elements with k disjoint cycles. The implementation is a wrapper to the function in FLINT.\n\nReferences\n\nOEIS\nWikipedia\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/#JuLie.stirling2","page":"Combinatorics","title":"JuLie.stirling2","text":"stirling2(n::fmpz, k::fmpz)\nstirling2(n::Integer, k::Integer)\n\nThe Stirling number S₂(n,k) of the second kind. This counts the number of partitions of an n-element set into k non-empty subsets. The implementation is a wrapper to the function in FLINT.\n\nReferences\n\nOEIS\nWikipedia\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/#Kostka-polynomials","page":"Combinatorics","title":"Kostka polynomials","text":"","category":"section"},{"location":"combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"kostka_polynomial\ncharge","category":"page"},{"location":"combinatorics/#JuLie.kostka_polynomial","page":"Combinatorics","title":"JuLie.kostka_polynomial","text":"kostka_polynomial(λ::Partition{T}, μ::Partition{T})\nkostka_polynomial(λ::Array{Int,1}, μ::Array{Int,1})\n\nThe (one-variable) Kostka polymial K_λμ(t) associated to partitions λ and μ can be defined as\n\nK_λμ(t) = _T  SSYT(λμ) t^charge(T)  ℕt\t\n\nwhere SSYT(λ,μ) is the set of all semistandard Young tableaux of shape λ and weight μ, and charge(T) is the charge of the tableau T. The Kostka polynomials relate the Hall–Littlewood polynomials P_μ to the Schur polynomials s_λ via\n\ns_λ(x_1x_n) = sum_μ K_λμ(t)P_μ(x_1x_nt)\n\nThis function returns the Kostka polynomial K_λμ(t) as an fmpz_poly over ZZ in t.\n\nExample\n\njulia> kostka_polynomial([4,2,1],[3,2,1,1])\nt^3 + 2*t^2 + t\n\nAlgorithm\n\nThe computation here is not based on the above formula but on an explicit description due to Kirillov–Reshetikhin in \"The Bethe ansatz and the combinatorics of Young tableaux\", J. Sov. Math. 41 (1988) 925., which is summarized by Dorey–Tonga–Turner in \"A matrix model for WZW\" (Apendix B). Namely:\n\nK_λμ(t)=_v_K=1^l(λ)-1_n1\nbeginbmatrix\nℙ_n^(K)+m_n(v^(K))\nm_n(v^(K))\nendbmatrix_t \n\nwhere the sum is over all admissible configurations v i.e. sequences of partitions v^(K) with\n\nv^(0)=μ text hspace2mm  v^(K)=_jK+1λ_j texthspace5mm and hspace5mm ℙ_n^(K)0\ttexthspace2mm for all hspace1mm n0 K=01l(λ)\n\nbeginaligned\n ℙ_n^(K) = _j1leftminleft(nv_j^(K+1)right) - 2minleft(nv_j^(K)right) + minleft(nv_j^(K-1)right)right\n\n c(v) = _i1(i-1)μ_i + _K=1^l(λ)-1left(𝕄leftv^(K) v^(K)right - 𝕄leftv^(K) v^(K-1)rightright)\n\n 𝕄ρκ = _ij1 min(ρ_iκ_j)\nendaligned\n\nHere, leftgenfrac0pt0mn right_t is the Gaussian binomial coefficient.\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/#JuLie.charge","page":"Combinatorics","title":"JuLie.charge","text":"charge(config::Array{Partition{T},1})\n\nThe charge c of an admissible configuration v= config, is defined by:\n\nbeginaligned\n c(v) = _i1(i-1)v^(0)_i + _K=1^l(λ)-1left(𝕄leftv^(K) v^(K)right - 𝕄leftv^(K) v^(K-1)rightright)\n\n 𝕄ρκ = _ij1 min(ρ_iκ_j)\nendaligned\n\n\n\n\n\ncharge(Tab::Tableau)\n\nreturns the charge of a Tableau Tab which is defined by the charge of it´s reading word.\n\ncharge(Tab):=charge(reading_word(Tab))\n\n\n\n\n\ncharge(word::Array{Int,1},standard=false::Bool)\n\nThis returns the charge of the Tableau corresponding to the reading word word.\n\nWe call a word standard, if each of its letters or numbers only appears once in it. If you are shure that your word is standard, you can set this argument to true, to improve the efficiency.\n\nThis Algorithm is based on the Algorithm following Example 7.3 in \"Hall-Littlewood Functions and Kostka-Foulkes Polynomials in Representation Theory\", J. Désarménien, B. Leclerc and J.-Y. Thibon.\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/#Schur-polynomials","page":"Combinatorics","title":"Schur polynomials","text":"","category":"section"},{"location":"combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"schur_polynomial","category":"page"},{"location":"combinatorics/#JuLie.schur_polynomial","page":"Combinatorics","title":"JuLie.schur_polynomial","text":"schur_polynomial(λ::Partition{T}, n=sum(λ)::Int) where T<:Integer\nschur_polynomial(λ::Partition{T}, R::FmpzMPolyRing, n=sum(λ)::Int) where T<:Integer\nschur_polynomial(λ::Partition{T}, x::Array{fmpz_mpoly,1}) where T<:Integer\n\nReturns the Schur polynomial s_λ(x₁x₂xₙ) in n variables, as a Multivariate Polynomial.\n\nIf neither R nor x are given, the Schur polynomial will be over PolynomialRing(ZZ,[\"x1\",\"x2\",...,\"xn\"]).\n\nExample\n\njulia> R,x = PolynomialRing(ZZ, [\"a\",\"b\",\"c\"])\n(Multivariate Polynomial Ring in a, b, c over Integer Ring, fmpz_mpoly[a, b, c])\njulia> schur_polynomial(Partition([2,1]),[x[1],x[2]])\na^2*b + a*b^2\njulia> schur_polynomial(Partition([2,1]),R)\na^2*b + a^2*c + a*b^2 + 2*a*b*c + a*c^2 + b^2*c + b*c^2\njulia> schur_polynomial(Partition([2]))\nx1^2 + x1*x2 + x2^2\n\nAlgorithm\n\nWe use two different Algorithms, depending on the size of the input. The Combinatorial Algorithm is used for Partitions of small Integers, or if n  10. In the other cases we use Cauchy's bialternant formula.\n\nCombinatorial Algorithm\n\ns_λ=_T x₁^m₁xₙ^mₙ\n\nwhere the sum is taken over all semistandard tableaux T of shape λ, and mᵢ gives the weight of i in T.\n\nCauchy's bialternant formula\n\ns_λ(x₁xₙ) =\t_1  i  j  n (x_i-x_j)^-1 \nbeginvmatrix\nx_1^λ₁+n-1  x_2^λ_1+n-1    x_n^λ_1+n-1 \nx_1^λ_2+n-2  x_2^λ_2+n-2    x_n^λ_2+n-2 \n       \nx_1^λ_n  x_2^λ_n    x_n^λ_n\nendvmatrix\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/#Quantum-analogs","page":"Combinatorics","title":"Quantum analogs","text":"","category":"section"},{"location":"combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"quantum_integer\nquantum_factorial\nquantum_binomial","category":"page"},{"location":"combinatorics/#JuLie.quantum_integer","page":"Combinatorics","title":"JuLie.quantum_integer","text":"quantum_integer(n::Int, q::RingElem)\n\nLet n  ℤ and let ℚ(𝐪) be the fraction field of the polynomial ring ℤ𝐪. The quantum integer n_𝐪  ℚ(𝐪) of n is defined as\n\nn_𝐪  frac𝐪^n-1𝐪-1 \n\nWe have\n\nn_𝐪 = sum_i=0^n-1 𝐪^i  ℤ𝐪 quad textif  n  0\n\nand\n\nn_𝐪 = -𝐪^n -n_𝐪 quad textfor any  n  ℤ \n\nhence\n\nn_𝐪 = - sum_i=0^-n-1 𝐪^n+i  ℤ𝐪^-1 quad text if  n  0 \n\nThis shows in particular that actually\n\nn_𝐪  ℤ𝐪𝐪^-1  ℚ(𝐪) quad text for any  n  ℤ \n\nNow, for an element q of a ring R we define n_q  R as the specialization of n_𝐪 in q using the two equations above—assuming that q is invertible in R if n0. Note that for q=1 we obtain\n\nn_1 = n quad textfor for any  n  ℤ \n\nso the quantum integers are \"deformations\" of the usual integers.\n\nIf the argument q is not specified, then n_𝐪 is returned as an element of ℤ𝐪𝐪^-1. If q is a Julia integer, then it is taken as an element of ZZ if n  0 or q =  1, otherwise it is taken as an element of QQ.\n\nExamples\n\njulia> quantum_integer(3)\nq^2 + q + 1\njulia> quantum_integer(-3)\n-q^-1 - q^-2 - q^-3\njulia> quantum_integer(-3,2)\n-7//8\n\nReferences\n\nConrad, K. (2000). A q-analogue of Mahler expansions. I. Adv. Math., 153(2), 185–230. https://doi.org/10.1006/aima.1999.1890\nKac, V. & Cheung, P. (2002). Quantum calculus. Springer-Verlag, New York.\nWikipedia, Q-analog.\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/#JuLie.quantum_factorial","page":"Combinatorics","title":"JuLie.quantum_factorial","text":"quantum_factorial(n::Int, q::RingElem)\n\nFor a non-negative integer n and an element q of a ring R the quantum factorial n_q  R is defined as\n\nn_q  1_q    n_q  R \n\nNote that for q=1 we obtain\n\nn_1 = n quad text for all  n  ℤ \n\nhence the quantum factorial is a \"deformation\" of the usual factorial.\n\nExamples\n\njulia> quantum_factorial(3)\nq^3 + 2*q^2 + 2*q + 1\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/#JuLie.quantum_binomial","page":"Combinatorics","title":"JuLie.quantum_binomial","text":"quantum_binomial(n::Int, q::RingElem)\n\nLet k be a non-negative integer and let n  ℤ. The quantum binomial beginbmatrix n  k endbmatrix_𝐪 in ℚ(𝐪) is defined as\n\nbeginbmatrix n  k endbmatrix_𝐪  fracn_𝐪k_𝐪 n-k_𝐪 = fracn_𝐪 n-1_𝐪   n-k+1_𝐪k_𝐪\n\nNote that the first expression is only defined for n  k since the quantum factorials are only defined for non-negative integers—but the second  expression is well-defined for all n  ℤ and is used for the definition. In Corad (2000) it is shown that\n\nbeginbmatrix n  k endbmatrix_𝐪 = sum_i=0^n-k q^i beginbmatrix i+k-1  k-1 endbmatrix_𝐪 quad textif  n  k  0 \n\nSince\n\nbeginbmatrix n  0 endbmatrix_𝐪 = 1 quad textfor all  n  ℤ\n\nand\n\nbeginbmatrix n  k endbmatrix_𝐪 = 0 quad textif  0  n  k \n\nit follows inductively that\n\nbeginbmatrix n  k endbmatrix_𝐪  ℤ𝐪 quad textif  n  0 \n\nFor all n  ℤ we have the relation\n\nbeginbmatrix n  k endbmatrix_𝐪 = (-1)^k 𝐪^-k(k-1)2+kn beginbmatrix k-n-1  k endbmatrix_𝐪 \n\nwhich shows that\n\nbeginbmatrix n  k endbmatrix_𝐪  ℤ𝐪^-1 quad textif  n  0 \n\nIn particular,\n\nbeginbmatrix n  k endbmatrix_𝐪  ℤ𝐪𝐪^-1 quad textfor all  n  ℤ \n\nNow, for an element q of a ring R we define beginbmatrix n  k endbmatrix_q as the specialization of beginbmatrix n  k endbmatrix_mathbfq in q, where q is assumed to be invertible in R if n  0.\n\nNote that for q=1 we obtain\n\nbeginbmatrix n  k endbmatrix_1 = n choose k \n\nhence the quantum binomial coefficient is a \"deformation\" of the usual binomial coefficient.\n\nExamples\n\njulia> quantum_binomial(4,2)\nq^4 + q^3 + 2*q^2 + q + 1\njulia> quantum_binomial(19,5,-1)\n36\njulia> K,i = CyclotomicField(4);\njulia> quantum_binomial(17,10,i)\n0\n\nReferences\n\nConrad, K. (2000). A q-analogue of Mahler expansions. I. Adv. Math., 153(2), 185–230. https://doi.org/10.1006/aima.1999.1890\nWikipedia, Gaussian binomial coefficient\n\n\n\n\n\n","category":"function"},{"location":"julie-index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"julie-index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Contributions are necessary and very much welcome! Here is some help on how to do this. I have written this document for those who are very new to developing in Julia, so you may skip many things—but please at least read the programming and documenting guidelines.","category":"page"},{"location":"contributing/#Setting-up-the-repository","page":"Contributing","title":"Setting up the repository","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you have previously installed JuLie as described in the installation section of the manual, you should remove it first to get a clean environment for developing: in Julia, hit the ] key to enter the Pkg mode, type rm JuLie, and exit Julia.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Everything around version control will be handled by Git and you need to have this installed. A quick introduction to Git is here. To contribute, it's best to have a GitHub account and fork my JuLie.jl repository. Clone your fork to somewhere on your computer:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"git clone https://github.com/YOUR_USERNAME/JuLie.jl","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Enter the directory JuLie.jl of your clone, start Julia, hit the ] key, and then register the package at this location for developing by typing","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"dev .","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Exit the Pkg mode by hitting the backspace key. Then you can start using the package as usual with:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using JuLie","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The idea of working with Git is that for any reasonable chunk of changes you do in the source code, you fix the state by doing a Git commit (with a reasonable description). Remeber to first add every new file via git add. As a commit is only a local thing, you need to eventually push all your commits to your repository on GitHub. If you're asked for your GitHub username and passwort at every push, then here is some advice on how to stop this.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"To merge your repository into mine, you do a pull request on GitHub. But before you do this, please make sure that everything is well-documented, the documentation builds correctly, and all tests pass.","category":"page"},{"location":"contributing/#Structure-of-JuLie","page":"Contributing","title":"Structure of JuLie","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The source files are located in the src directory. The main source file is src/JuLie.jl. Three things are happening here:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Importing structures and functions from other packages. I have decided to do the imports one by one instead of doing a full import of everything from, e.g., OSCAR, to keep JuLie slick and have maximal control. All these structures and functions can be used directly in the JuLie code. If necessary, you may add more imports here (as long as you're developing and haven't finally decided on what you actually need, I recommend putting the new imports in the source file you're working on first).\nExporting structures and functions. This only concerns exports of some of the imports above and I am doing this for convenience so that, e.g., one can directly create a polynomial ring from within JuLie without having to load AbstractAlgebra or Nemo first. The exports of functions implemented in JuLie itself are located in the various source files.\nInclusion of all the various source files of JuLie.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"To ensure proper functionality of JuLie we use unit testing. The directory test contains various test sets, and these are combined in the file runtests.jl. You can run the complete unit test with Pkg.test(\"JuLie\").","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The documentation is automatically built on GitHub using the package Documenter.jl from the comments in the source files together with the Markdown files in the docs/src directory. The file docs/make.jl defines the structure of the navigation panel. You can build the documentation locally by running julia make.jl local; the result is then in the build directory.","category":"page"},{"location":"contributing/#Programming","page":"Contributing","title":"Programming","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you are completely new to Julia, I recommend reading my Julia crash course. Eventually, you will need to look things up in the official Julia documentation. I recommend browsing through some of the source files of JuLie to get a quick impression of the programming style. Here are some guidelines:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We follow the official Julia style guide (except for the next point).\nWe use one hard tab for indentation.\nUnicode in the source code is allowed and encouraged to increase readability. The LaTex-like abbreviations for unicode characters can be used in, e.g., the Atom editor.\nRemember that we want to use basic algebraic structures provided by (subpackages of) OSCAR.\nMathematical structures you implement should somehow reflect how they are defined and treated abstractly. This is often easier said than done and one really needs to think about this before implementing anything.\nIf your implementation is not faster than those in other computer algebra systems then it's not good enough. (Don't take this too seriously, but at least try. I prefer to have a not incredibly fast algorithm than no algorithm at all, especially if the structures are mathematically sound so that we can improve functions at a later stage without having to do structural changes). Please read the Julia performance guide to not fall into typical traps.\nFor every function you implement, you should add a reasonable test to the unit testing. Try to find computed examples in publications or which follow from general theory etc.","category":"page"},{"location":"contributing/#Documenting","page":"Contributing","title":"Documenting","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Everything has to be well-documented, algorithms and papers have to be properly referenced. Here are some guidelines:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"To express mathematics in the documentation we use unicode, and for the more complicated things we combine this with LaTeX. Here's an example of how this is done:\n@doc raw\"\"\"\n\tquantum_integer(n::Int, q::RingElem)\nLet ``n ∈ ℤ`` and let ``ℚ(𝐪)`` be the fraction field of the polynomial ring ``ℤ[𝐪]``...\n\"\"\"\nfunction quantum_integer(n::Int, q::RingElem)\n  ...\nend\nEverything between the `` is interpreted as LaTex. You can add similar comments for structures. The comments can be integrated in the documentation by adding the function (or structure) name to the Markdown files in the docs/src directory.\nWe use an \"Examples\" section in the documentation block to give some examples.\nWe use a \"References\" section at the end of a documentation block to list references. The references are given in APA style, e.g. \"Etingof, P. & Ginzburg, V. (2002). Symplectic reflection algebras, Calogero-Moser space, and deformed Harish-Chandra homomorphism. Invent. Math., 147(2), 243–348. https://doi.org/10.1007/s002220100171\". In-text references in APA style look like \"Etingof & Ginzburg (2002)\". You can use BibDesk and my APA export template to save time dealing with this.","category":"page"},{"location":"contributing/#The-Revise-package","page":"Contributing","title":"The Revise package","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you have a running Julia session with JuLie loaded, then changes you make to the JuLie code will have no effect in the running Julia session—you have to restart it. This is simply the way Julia works. But this is annoying when developing. A solution is to use the Revise package. You can install it with","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.add(\"Revise\")","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"and then you need to load it before loading the package you're working on:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Revise\nusing JuLie","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Now, changes you make in the code are immediately available in the running Julia session (except for changes to structures, here you still need to restart).","category":"page"},{"location":"#JuLie","page":"JuLie","title":"JuLie","text":"","category":"section"},{"location":"","page":"JuLie","title":"JuLie","text":"JuLie is an early-stage package for the programming language Julia with the goal of providing mathematically sound structures and fast algorithms for things around representation theory, especially algebraic Lie theory and accompanying combinatorics. These fields are huge and this package is still small—I hope it will grow with time. Contributions are necessary and very much welcome!","category":"page"},{"location":"","page":"JuLie","title":"JuLie","text":"By Ulrich Thiel (University of Kaiserslautern) and contributors.","category":"page"},{"location":"#Installation","page":"JuLie","title":"Installation","text":"","category":"section"},{"location":"","page":"JuLie","title":"JuLie","text":"You first need to install Julia (this works on any operating system). Then after starting Julia, type the following to install this package:","category":"page"},{"location":"","page":"JuLie","title":"JuLie","text":"julia> using Pkg\njulia> Pkg.add(url=\"https://github.com/ulthiel/JuLie.jl\")","category":"page"},{"location":"","page":"JuLie","title":"JuLie","text":"Now, you can start using JuLie by typing:","category":"page"},{"location":"","page":"JuLie","title":"JuLie","text":"julia> using JuLie","category":"page"},{"location":"","page":"JuLie","title":"JuLie","text":"Here's an example:","category":"page"},{"location":"","page":"JuLie","title":"JuLie","text":"julia> partitions(3)\n3-element Vector{Partition{Int64}}:\n [3]\n [2, 1]\n [1, 1, 1]\njulia> @time partitions(Int8(90)); #One goal of JuLie is being fast :-)\n  5.844981 seconds (56.63 M allocations: 6.239 GiB, 19.75% gc time)","category":"page"},{"location":"#Motivation","page":"JuLie","title":"Motivation","text":"","category":"section"},{"location":"","page":"JuLie","title":"JuLie","text":"Especially for combinatorics there's a lot already in other computer algebra systems and this justifies the question: why another package? I have two reasons: 1) Julia has a straightforward high-level syntax (like Python) paired with incredible performance (unlike Python), see my benchmarks; 2) Julia with its type system and multiple dispatch is ideal to model mathematics closely to how you think abstractly. Because of the OSCAR project (see also my summary here), we do not need to start from scratch. One of my distant goals is to have \"all\" the material available from (and as in) the book Introduction to Soergel bimodules with B. Elias, S. Makisumi, and G. Williamson.","category":"page"},{"location":"#Acknowledgments","page":"JuLie","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"JuLie","title":"JuLie","text":"This is a contribution to Project-ID 286237555 – TRR 195 – by the Deutsche Forschungsgemeinschaft. I thank everyone who contributed (see below). The logo shows the root system of type G₂ and is taken from Wikipedia.","category":"page"},{"location":"#Contributors","page":"JuLie","title":"Contributors","text":"","category":"section"},{"location":"","page":"JuLie","title":"JuLie","text":"Max Horn (TU Kaiserslautern, 2020): Julia generalities\nTom Schmit (TU Kaiserslautern, 2020–2021): Cartan matrices, Coxeter groups, Documenter.jl and GitHub integration, Kostka polynomials, Schur polynomials, Tableaux\nElisa Thiel (2020): De-gotoing old ALGOL code","category":"page"},{"location":"lie-theory/#Lie-Theory","page":"Lie theory","title":"Lie Theory","text":"","category":"section"},{"location":"lie-theory/#Cartan-matrices","page":"Lie theory","title":"Cartan matrices","text":"","category":"section"},{"location":"lie-theory/","page":"Lie theory","title":"Lie theory","text":"CartanMatrix\nis_cartan_matrix\nis_square\nadjacency_graph\npermute\nblock_decomposition\nis_indecomposable","category":"page"},{"location":"lie-theory/#JuLie.CartanMatrix","page":"Lie theory","title":"JuLie.CartanMatrix","text":"struct CartanMatrix <: MatElem{fmpz}\n\nA (generalized) Cartan matrix is a square matrix C over the integers satisfying the following conditions:\n\nbeginaligned\n C_ii = 2  \n\n C_ij  0 quad text for  quad ij \n\n C_ij = 0 quad Leftrightarrow quad C_ji = 0 \nendaligned\n\nThis definition is as in Carter (2005). Note that in Kac (1990) more generally matrices over the complex numbers are considered—but most of the literature just focuses on the integral case.\n\nYou can create a CartanMatrix with\n\nCartanMatrix( \"A4~\" )\t #calls essentially CartanMatrix('A', 4, true)\nCartanMatrix( \"C6\" )\t\t#calls essentially CartanMatrix('C', 6)\n\nwhich generates the CartanMatrix: tildeA_4 resp. C_6\n\nIf you would like to generate block diagonal matrices you can do so with\n\nCartanMatrix([\"A3~\",\"G2\",\"B12\"])\t#calls essentially CartanMatrix(['A','G','B'],[3,2,12],[true,false,false])\n\nReferences\n\nCarter, R. (2005). Lie Algebras of Finite and Affine Type. Cambridge University Press, Cambridge.\nKac, V. G. (1990). Infinite dimensional Lie algebras (Third edition). Cambridge University Press, Cambridge. (First edition published 1982)\n\n\n\n\n\n","category":"type"},{"location":"lie-theory/#JuLie.is_cartan_matrix","page":"Lie theory","title":"JuLie.is_cartan_matrix","text":"is_cartan_matrix(C::CartanMatrix)\n\nReturns true iff C is a (generalized) Cartan matrix.\n\n\n\n\n\n","category":"function"},{"location":"lie-theory/#JuLie.is_square","page":"Lie theory","title":"JuLie.is_square","text":"is_square(M::MatElem)\n\nReturns true iff M is a square matrix, i.e. the number of rows is equal to the number of columns. If true, the dimension is returned as well.\n\n\n\n\n\n","category":"function"},{"location":"lie-theory/#JuLie.adjacency_graph","page":"Lie theory","title":"JuLie.adjacency_graph","text":"adjacency_graph(M::MatElem)\n\nThe adjacency graph of an (n  n)-matrix M is the undirected graph with vertices 1n and an edge from i to j if and only if i ne j and M_ij  0. The adjacency graph is returned as a SimpleGraph fom the LightGraphs package.\n\n\n\n\n\n","category":"function"},{"location":"lie-theory/#JuLie.permute","page":"Lie theory","title":"JuLie.permute","text":"permute(M::MatElem, σ::Perm)\n\nGiven an (n  n)-matrix M and a permutation σ  S_n, this function returns the matrix M^sigma with (M^sigma)_ij  M_sigma(i) sigma(j), i.e. the rows and columns are permuted by σ.\n\n\n\n\n\n","category":"function"},{"location":"lie-theory/#JuLie.block_decomposition","page":"Lie theory","title":"JuLie.block_decomposition","text":"block_decomposition(M::MatElem)\n\nLet M be an (n  n)-matrix. A block decomposition of M is a collection of square matrices B_1ldotsB_r together with a permutation σ  S_n such that the matrix M^sigma obtained by applying the permutation sigma to the rows and columns of M is the block diagonal sum of the B_i. Up to reordering of the B_i and up to simulatenous row and column permutation of each B_i, a block decomposition is unique and corresponds to the connected components of the adjacency graph of M.\n\n\n\n\n\n","category":"function"},{"location":"lie-theory/#JuLie.is_indecomposable","page":"Lie theory","title":"JuLie.is_indecomposable","text":"is_indecomposable(C::MatElem)\n\nA square matrix M is indecomposable if it has no non-trivial block decomposition, i.e. the adjacency graph of M is connected.\n\n\n\n\n\n","category":"function"},{"location":"julia-crash/#julia-crash","page":"Julia crash course","title":"Julia crash course","text":"","category":"section"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"Julia is a high-level, high-performance, dynamic programming language that first appeared in 2012 and gained quite a lot of popularity. To get a quick overview, I recommend checking out the Wikipedia article. You can learn all the basics of Julia from the official documentation but as this is quite a lot to read, I'll mention a few key points.","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"First of all, you may have noticed that the first time you call a function like partitions(10) it takes a bit of time to get an answer—but the second time you call it (with any argument) the answer is immediate. This is because Julia uses just-in-time (JIT) compilation, which means it compiles code at run time just before it is actually needed. This is part of what makes Julia so fast—with the tradeoff that there will be a delay in the first call of a function.","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"Second, there are two—but likely more—caveats for algebraists in Julia: integers are by default 64-bit integers and division is floating point division:","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"julia> 2^64\n0\njulia> typeof(2)\nInt64\njulia> 6/9\n0.6666666666666666\njulia> typeof(6/9)\nFloat64","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"This is of course not what we want. Before we fix this, notice from the example above that every object in Julia is of a certain type, e.g. Int64 in case of the number 2. An object of a type called MyType can be created from input data required by this type by calling MyType(...), where the dots represent the input data. For example, Julia provides the type BigInt for big integers (based on the GMP library) and we can create big integers as follows:","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"julia> a = BigInt(2)\n2\njulia> typeof(a)\nBigInt\njulia> a^64\n18446744073709551616","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"Much better! Typically, names of types start with an uppercase letter while names of functions start with a lowercase letter. The operator for exact division in Julia is the double slash //:","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"julia> x = 6//9\n2//3\njulia> typeof(x)\nRational{Int64}","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"You see that there is a type Rational for (exact) rational numbers in Julia. This type is actually a parametric type Rational{T} which means that it refers to rational numbers created from integers of type T—in this case 64-bit integers. I'll leave it to you to find out the type of a division of two big integers.","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"You can implement your own types, e.g. here is how I implemented a type for partitions:","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"struct Partition{T} <: AbstractArray{T,1}\n\t p::Array{T,1}\nend","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"This means that Partition{T} is a parametric subtype of AbstractArray{T,1}, the latter being the parametric type of (abstract) one-dimensional arrays. The array is internally stored in the field called p and this field will be filled by the type constructor:","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"julia> P = Partition([6,4,3,1]);\njulia> typeof(P)\nPartition{Int64}\njulia> P.p\n4-element Vector{Int64}:\n 6\n 4\n 3\n 1","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"As you can see in the partition type example, you can build up a hierarchy—a tree—of types but it is important to note that only the leaves of this tree can be instantiated: there is a distinction between concrete types (the leaves) and abstract types (everything else). If you want to know more, you should read the section about types in the Julia documentation.","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"Functions in Julia are implemented in such a way that one specifies the type of the parameters, e.g. I have implemented a function to obtain the conjugate of a partition and this looks like:","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"function conjugate(P::Partition{T}) where T<:Integer\n  #some code\nend","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"Let's try it in the above example:","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"julia> conjugate(P)\n[4, 3, 3, 2, 1, 1]","category":"page"},{"location":"julia-crash/","page":"Julia crash course","title":"Julia crash course","text":"Beautiful. Now, one of the backbones of Julia is that you can implement a separate function with the same name conjugate but acting on a different type in a different way. This concept is called multiple dispatch. Using types and multiple dispatch one can model mathematical structures quite closely to how one abstractly thinks about them and this is another very good reason why Julia is a great choice for modern computer algebra.","category":"page"}]
}
